import { getFakeMathRandom } from './getFakeMathRandom.ts';
import type { SpawnedSeedFn, SpawnSeedFn } from './makeSeedFn.ts';
import type { SeedLike } from './Seed.ts';
import { Seed } from './Seed.ts';

/**
 * Given a base function, returns a new function that accepts options to preconfigure the base function.
 * When invoked with the options, the new function returns a custom version of `makeSeedFn`:
 * it behaves identically, but its seeds are generated using the preconfigured base function instead of `Math.random`.
 *
 * For example, given a function that returns a random integer between 0 and nMax, we can create a custom `makeSeedFn`
 * that uses seeds between 0 and nMax, and then set nMax to 100:
 *
 * ```ts
 * function randomInt(nMax: number) {
 *   return Math.floor(Math.random() * nMax);
 * }
 * const deriveMakeSeedFn = deriveMakeSeedFn(randomInt)(100);
 * ```
 *
 * The key to this function is `getFakeMathRandom`, which returns a deterministic, pseudo-random
 * sequence of outputs when given a seed. The predictable values generated by that function are
 * extrapolated to create deterministic values from `fn`.
 */
export function deriveMakeSeedFn<TOptions extends object>(fn: (options?: OptionsWithSeed<TOptions>) => number) {
  return function configureMakeSeedFn(options: OptionsWithSeed<TOptions>): MakeSeedFn {
    if (options?.seed) {
      throw new Error('Unexpected seed value. Omit the seed when deriving the function.');
    }
    return function makeSeededFn(seed?: SeedLike): [seedFn: () => number, baseSeed: number] {
      let base = Seed.evaluate(seed) ?? fn({ ...options, seed });
      function seedFn(cb?: (base: number) => void): number {
        const newValue = fn({ ...options, seed: getFakeMathRandom(base) });
        base = sumWithWrap(base, 1);
        if (cb) cb(base);
        return newValue;
      }
      return [seedFn, base];
    };
  };
}

/**
 * Convenience function that combines `makeSeedFn` and `deriveSpawnSeedFn`.
 *
 * Returns a tuple containing
 * - a custom `makeSeedFn` function that uses the given function to generate seeds
 * - a custom `spawnSeedFn` function that uses the custom `makeSeedFn` function
 */
export function deriveSeedFns<TOptions extends object>(fn: (options?: OptionsWithSeed<TOptions>) => number) {
  return function configureMakeSeedFn(options: OptionsWithSeed<TOptions>): [MakeSeedFn, SpawnSeedFn] {
    if (options?.seed) {
      throw new Error('Unexpected seed value. Omit the seed when deriving the function.');
    }
    function getSeedFnWithBase(seed?: SeedLike): [seedFn: () => number, baseSeed: number] {
      let base = Seed.evaluate(seed) ?? fn({ ...options, seed });
      function seedFn(): number {
        const newValue = fn({ ...options, seed: getFakeMathRandom(base) });
        base = sumWithWrap(base, 1);
        return newValue;
      }
      return [seedFn, base];
    }
    return [getSeedFnWithBase, deriveSpawnSeedFn(getSeedFnWithBase)];
  };
}

/**
 * Given a custom `makeSeedFn` function, returns its corresponding `spawnSeedFn`.
 * The function behaves identically to `spawnSeedFn`, but its seeds are generated using the custom `makeSeedFn`.
 */
export function deriveSpawnSeedFn(fn: MakeSeedFn): SpawnSeedFn {
  return function customSpawnSeedFn(seed?: SeedLike): SpawnedSeedFn {
    return seed === undefined ? undefined : fn(seed)[0];
  };
}

// region | Helpers
/**
 * Returns the sum two numbers, wrapping around from 0 if the result exceeds `Number.MAX_SAFE_INTEGER`.
 */
function sumWithWrap(a: number, b: number) {
  return a > (Number.MAX_SAFE_INTEGER - b) ? (a - Number.MAX_SAFE_INTEGER + b) : a + b;
}
// endregion | Helpers

// region | Types
// TODO: The callback is currently included for testing & debugging; remove if no longer useful.
type MakeSeedFn = (seed?: SeedLike) => [seedFn: (cb?: (base: number) => void) => number, baseSeed: number];

type OptionsWithSeed<TOptions extends object> = TOptions & SeedOptions;

interface SeedOptions {
  seed?: SeedLike | undefined;
}
// endregion | Types
